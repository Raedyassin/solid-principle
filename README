
# Table of Content
- [What is SOLID Principle](#what-is-solid-principle)
- [What Problems Does SOLID Come to Solve](#what-problems-does-solid-come-to-solve)
- [What is this Principle](#what-is-this-principle)
  1. [Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)
  2. [Open-Closed Principle (OCP)](#open-closed-principle-ocp)
  3. [Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)
  4. [Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)
  5. [Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)
- [Resources](#resources)



# What is SOLID Principle

**SOLID** is five design principles intended to make object-oriented designs more:  
- understandable  
- flexible  
- maintainable  
- testable  
- reusable  

Think of them as **rules of thumb for writing good, clean Object-Oriented code**, much like grammar rules for writing clear sentences.  



# What Problems Does SOLID Come to Solve

1. Classes or functions become **too big** and handle multiple concerns.  
2. Every time **requirements change**, you must **modify old code**.  
3. Wrong inheritance ‚Üí subclasses do not behave like their parent.  
4. Interfaces become **too large**, forcing classes to implement methods they do not need.  
5. Code is **tightly coupled to concrete implementations**.  


# What is this Principle

### 1. **Single Responsibility Principle (SRP)**  
### 2. **Open/Closed Principle (OCP)**  
### 3. **Liskov Substitution Principle (LSP)**  
### 4. **Interface Segregation Principle (ISP)**  
### 5. **Dependency Inversion Principle (DIP)**  
![SOLID Principle](./assets/solid.png)

# Single Responsibility Principle (SRP)

## What is SPR

>A **class** or **function** *should have only one reason to change*

**Analogy:**¬†A restaurant. A chef cooks the food, a waiter serves the food, and a cashier handles payments. *You wouldn't want the chef also trying to take orders and handle money.*

### What does **"Reason to Change"** mean?
¬†It means¬†**a change in a business requirement, rule, or concern**.

Think of it this way:¬†**Who might ask for a change?**
- The¬†**CEO**¬†might request a change to how employee bonuses are calculated.
- The¬†**HR department**¬†might change the rules for generating performance reports.
- The¬†**IT security team**¬†might change the protocol for saving data to the database.

Each of these groups represents a different "actor" in the system with a different agenda. Each agenda is a separate "reason to change."

If a single class contains logic that could be changed by more than one of these actors, it has more than one reason to change and violates the SRP.

## Example: A "User" Class with Multiple Responsibilities
``` ts
class User {
  private username: string;
  private email: string;
  private hashedPassword: string;

  constructor(username: string, email: string, hashedPassword: string) {
    this.username = username;
    this.email = email;
    this.hashedPassword = hashedPassword;
  }

  // Responsibility #1: User Data Management
  changeEmail(newEmail: string): void {
    if (!this.isValidEmail(newEmail)) {
      throw new Error("Invalid email");
    }
    this.email = newEmail;
  }

  private isValidEmail(email: string): boolean {
    // ... validation logic
    return true;
  }

  // Responsibility #2: Authentication
  login(password: string): boolean {
    const inputHash = this.hashPassword(password);
    return inputHash === this.hashedPassword;
  }

  private hashPassword(password: string): string {
    // simplified hashing logic
    return password;
  }

  // Responsibility #3: Database Persistence
  saveToDatabase(): void {
    console.log("Saving user to database...");
  }

  // Responsibility #4: Notifications
  sendEmail(subject: string, body: string): void {
    console.log(`Sending email to ${this.email}`);
  }
}

```

there are 4 Responsibility in `User` class, in good design it should have only Responsibility that `User` Responsibility like this 

```ts
export class User {
  private id: string;
  private username: string;
  private email: string;
  private password: string;
  private isActive: boolean;

  constructor(id: string, username: string, email: string, password: string) {
    this.id = id;
    this.username = username;
    this.email = email;
    this.password = password;
    this.isActive = true;
  }

  getId(): string {
    return this.id;
  }

  getUsername(): string {
    return this.username;
  }

.... //user logic
}

```
other Responsibility
```ts
// 2. Authentication Service: Handles login and password security.
//    Reason to change: Security policy changes (e.g., new hashing algorithm).
class AuthService {
  login(user: User, password: string): boolean {
    const inputHash = this.hashPassword(password);
    return inputHash === user["password"]; // accessing private for demo (better via getter)
  }

  private hashPassword(password: string): string {
    // Replace with real hashing (bcrypt, argon2, etc.)
    return password;
  }
}


// 3. Repository Pattern: Handles all database operations for a User.
//    Reason to change: The database technology or schema changes.
export class UserRepository {
  save(user: User): void {
    console.log(`Saving user ${user.getUsername()} to database...`);
    // DB logic here
  }

  findById(id: string): User | null {
    // DB query simulation
    console.log(`Fetching user with id ${id}...`);
    return null;
  }
}


// 4. Notification Service: Handles sending emails/notifications.
//    Reason to change: The way we send notifications changes (e.g., new email provider).
export class EmailService {
  sendEmail(subject, body): void {
    console.log(`Sending email to userName ${subject} - ${body}`);
  }
}

// 5. Validation Utility: Handles validation logic.
//    Reason to change: Validation rules change.
export class ValidationUtils {
  static isValidEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
}
```

# Open-Closed Principle (OCP)

>Software **entities** (classes, modules, functions, etc.) should be *open for extension* but *closed for modification*.

## What does that mean?
- **Open for extension** ‚Üí You should be able to **add new functionality**.
- **Closed for modification** ‚Üí You should **not need to change existing code** to add that functionality.

don‚Äôt keep editing the same class **every time requirements change**. Instead, design it so you can **extend it** (via *inheritance*, *interfaces*, *composition*, or *polymorphism*).

## Example
```ts

class ReportGenerator {

  generate(type: string, data: any) {
    if (type === "pdf") { // for Pdf
      console.log("Generating PDF report...");
    } else if (type === "csv") { // for csv
      console.log("Generating CSV report...");
    } else if (type === "json") { // for json
      console.log("Generating JSON report...");
    }
  }
}

```
Problems:
- Every time you add a new format (`Excel`, `XML`), you must **modify this class**.by do this 
```ts

class ReportGenerator {

  generate(type: string, data: any) {
    if (type === "pdf") { // for Pdf
      console.log("Generating PDF report...");
    } 
    .... // the above code
    else if (type === "Excel") { // for csv
      console.log("Generating Excel report...");
    } else if (type === "XML") { // for json
      console.log("Generating XML report...");
    }
  }
}

```
solution 
 - by follow OCP 
 ```ts
 
interface Report {
  generate(data: any): void;
}

// Extensions
class PdfReport implements Report {
  generate(data: any) {
    console.log("Generating PDF report...");
  }
}

// Extensions
class CsvReport implements Report {
  generate(data: any) {
    console.log("Generating CSV report...");
  }
}

// Extensions
class JsonReport implements Report {
  generate(data: any) {
    console.log("Generating JSON report...");
  }
}

class ReportGenerator {
  constructor(private report: Report) {}
  
  // Context (open/closed principle applied)
  generate(data: any) {
    this.report.generate(data);
  }
}

// Usage
const pdfReport = new ReportGenerator(new PdfReport());
pdfReport.generate({ title: "Sales Report" });

const csvReport = new ReportGenerator(new CsvReport());
csvReport.generate({ title: "Sales Report" });

 ```
###### now when you wanna add new feature like add `XML` you will add new class and the original code don't change

# Liskov Substitution Principle (LSP)

> _Objects of a superclass should be replaceable with objects of its subclasses without breaking the correctness of the program._

Meaning:
If `B` is a subclass of `A`, then you should be able to use `B` **anywhere `A` is expected**, Without the program being bad.

>The whole problem lies in the behavior of methods. When the parent provides a method, the child should fully support it and maintain the same contract (with his rule but support the behavior).

## üîπ What does **behavior** mean here?
When we design a parent class (or interface), we are **promising a certain behavior (contract)**.
- Behavior = **how a method is expected to work** + **the guarantees it gives**.
- Subclasses must keep that promise.
If a subclass changes that behavior in a way that breaks the promise, it **violates LSP**.

# Example
```ts
class Bird {
  fly(): string {
    return "I can fly!";
  }
}

```
The **behavior** promised is:
- All `Bird`s can `fly`.
break the contract
```ts
class Penguin extends Bird {
  fly(): string {
    throw new Error("Penguins can't fly!"); // ‚ùå Breaks the promise
  }
}

```
- `Penguin` changes the **behavior** (instead of flying, it crashes).

### LSP solution
```ts
class Bird {
  makeSound(): void {
    console.log("Some bird sound");
  }
}

interface Flyable { // ‚úÖ solution
  fly(): void;
}

class Sparrow extends Bird implements Flyable {
  fly(): void {
    console.log("Sparrow flying!");
  }
}

class Penguin extends Bird {
  swim(): void {
    console.log("Penguin swimming!");
  }
}

```
- Now the **behavior is consistent**:
    - `Flyable` ‚Üí always flies.
    - `Bird` ‚Üí always makes sound.
    - No surprises.

## Why LSP matters
- Prevents **wrong inheritance** (forcing ‚Äúis-a‚Äù relationships where they don‚Äôt belong).
- Makes sure **subclasses don‚Äôt break parent expectations**.
- Keeps polymorphism safe.

## You can say
**‚ÄúIf a subclass cannot behave exactly like its parent in all cases, it violates LSP.‚Äù**

# Interface Segregation Principle (ISP)

> ‚ÄúNo client should be forced to depend on methods it does **not use**.‚Äù

In other words:
- Interfaces (abstract class ) should be **small and specific**.
- Don‚Äôt create ‚Äúfat‚Äù interfaces that make classes implement methods they don‚Äôt need.
- Makes the code **flexible, reusable, and clean**.
-  from his name make separation for interface don't make it have all the methods

## üîπ Example: Payment System
### Wrong
```ts
interface FileOperations {
  readFile(path: string): string;
  writeFile(path: string, content: string): void;
  compressFile(path: string): void;
  encryptFile(path: string): void;
}

```
**Problem:**
- If I **only want to implement** a simple `ReadOnlyFileReader`, I still have to implement `writeFile`, `compressFile`, and `encryptFile` ‚Äî even though they don‚Äôt make sense.
### ‚úÖ Correct Design (Respecting ISP)
```ts
interface Readable {
  readFile(path: string): string;
}

interface Writable {
  writeFile(path: string, content: string): void;
}

interface Compressible {
  compressFile(path: string): void;
}

interface Encryptable {
  encryptFile(path: string): void;
}

class ReadOnlyFileReader implements Readable {
  readFile(path: string): string {
    return `Reading file from ${path}`;
  }
}

class SecureFileWriter implements Writable, Encryptable {
  writeFile(path: string, content: string): void {
    console.log(`Writing to ${path}`);
  }

  encryptFile(path: string): void {
    console.log(`Encrypting ${path}`);
  }
}

```
‚úÖ **Now:**
- `ReadOnlyFileReader` is not forced to implement useless methods.
- `SecureFileWriter` only implements what it really needs.

# Dependency Inversion Principle (DIP)

> **High-level modules should not depend on low-level modules. Both should depend on abstractions level.**  
> 
> Abstractions should not depend on details. Details should depend on abstractions.

I think
> ‚ÄúFrom its name, Dependency Inversion means inverting the relationship between two classes: *instead of high-level classes depending on low-level classes*, **both depend on an abstraction**. This hides the details (implementation) behind the abstraction. 
> 
> Following this principle also helps achieve the **Open/Closed Principle (OCP)**, because we can add new implementations without modifying the high-level code.‚Äù

- **DIP (Dependency Inversion Principle)** ‚Üí a **principle/rule** that says:  
    _‚ÄúDepend on abstractions, not on concrete implementations.‚Äù_
- **DI (Dependency Injection)** ‚Üí a **technique/pattern** that we usually use to **apply DIP in real code**.
So:
- DIP tells you **what you should do** (invert dependency direction).
- DI tells you **how to do it** (inject dependencies via constructor, property, or method).

*solve tight coupling problem*

## Example 1
```ts
// High-level: UserService
class UserService {
  private db: MySQLDatabase; // ‚ùå depends on concrete implementation

  constructor() {
    this.db = new MySQLDatabase();
  }

  getUsers(): string[] {
    return this.db.query(sql);
  }
}

// Low-level: specific database
class MySQLDatabase {
  query(sql: string): string[] {
    console.log("Querying MySQL:", sql);
  }
}

const userService = new UserService();
console.log(userService.getUsers());

```
**Problem:**
- `UserService` depends **directly on MySQLDatabase**.
- If you switch to PostgreSQL, MongoDB, or an API, you must rewrite `UserService`.
## apply DIP by DI (Dependency Injection)
```ts

interface Database {
  query(sql: string): string[];
}

// Low-level implementation (MySQL)
class MySQLDatabase implements Database {
  query(sql: string): string[] {
    console.log("Querying MySQL:", sql);
  }
}

// Another implementation (PostgreSQL)
class PostgreSQLDatabase implements Database {
  query(sql: string): string[] {
    console.log("Querying PostgreSQL:", sql);
  }
}

// High-level depends on abstraction, not concrete class
class UserService {
  constructor(private db: Database) {} // ‚úÖ injection of abstraction

  getUsers(): string[] {
    return this.db.query();
  }
}

// Usage
const mysqlDb = new MySQLDatabase();
const postgresDb = new PostgreSQLDatabase();

const userService1 = new UserService(mysqlDb);
console.log(userService1.getUsers()); // from MySQL

const userService2 = new UserService(postgresDb);
console.log(userService2.getUsers()); // from PostgreSQL

```
‚úÖ **Now:**
- `UserService` only depends on `Database` (abstraction).
- Any DB implementation can be injected (MySQL, PostgreSQL, MongoDB, mock for testing, etc.).
- Swapping implementations requires **no changes** in high-level code.

## Another Example
Violation DIP
![Violation DIP](./assets/dip-problem.png)

apply DIP
![apply DIP](./assets//dip-solution.png)

# Resources
- [Mohammed Reda Playlist (Youtube)](https://www.youtube.com/playlist?list=PLnqAlQ9hFYdflFSS4NigVB7aSoYPNwHTL)
- [Wikipedia (SOLID) and other nested documents](https://en.wikipedia.org/wiki/SOLID)
